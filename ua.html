---
layout: default
---


<button class="action action--open" aria-label="Open Menu"><span class="icon icon--menu"></span></button>
<nav id="ml-menu" class="menu">
  <button class="action action--close" aria-label="Close Menu"><span class="icon icon--cross"></span></button>
  <div class="menu__wrap">

    <ul data-menu="main" class="menu__level">
      <li class="menu__item"><a class="menu__link" href="#describe">Опишіть методи</a></li>
      <li class="menu__item"><a class="menu__link" href="#contexts">Використовуйте context</a></li>
      <li class="menu__item"><a class="menu__link" href="#short">Лаконічний опис</a></li>
      <li class="menu__item"><a class="menu__link" href="#single">Єдиний очікуваний результат</a></li>
      <li class="menu__item"><a class="menu__link" href="#all">Всі можливі випадки</a></li>
      <li class="menu__item"><a class="menu__link" href="#expect">Expect проти should</a></li>
      <li class="menu__item"><a class="menu__link" href="#subject">Використовуйте subject</a></li>
      <li class="menu__item"><a class="menu__link" href="#let">Використовуйте let і let!</a></li>
      <li class="menu__item"><a class="menu__link" href="#mock">Мокати чи не мокати</a></li>
      <li class="menu__item"><a class="menu__link" href="#data">Створюйте дані, які вам потрібні</a></li>
      <li class="menu__item"><a class="menu__link" href="#factories">Використовуйте фабрики</a></li>
      <li class="menu__item"><a class="menu__link" href="#matchers">Легкі для розуміння метчери</a></li>
      <li class="menu__item"><a class="menu__link" href="#shared">Shared Examples</a></li>
      <li class="menu__item"><a class="menu__link" href="#integration">Тестуйте те що бачите</a></li>
      <li class="menu__item"><a class="menu__link" href="#should">Не використовуйте should</a></li>
      <li class="menu__item"><a class="menu__link" href="#continuous">Безперервне тестування</a></li>
      <li class="menu__item"><a class="menu__link" href="#faster">Швидші тести</a></li>
      <li class="menu__item"><a class="menu__link" href="#stubbing">Запишіть HTTP запити</a></li>
      <li class="menu__item"><a class="menu__link" href="#formatter">Форматувач</a></li>
      <li class="menu__item"><a class="menu__link" href="#contributing">Долучитися до проекту</a></li>
    </ul>

  </div>
</nav>
<div class="content">


  <article>

    <h1><a name="what">Що таке Better Specs</a></h1>

    <p>
      {{ site.description }}
      Better Specs був створений <a target="_blank" href="https://lelylan.com">Lelylan</a> (open source IoT хмарній платформі <a target="_blank" href="https://github.com/lelylan/lelylan"> зацініть їхні test suite</a> це може надихнути вас)
    </p>

    <p class="info">
       Better Specs сфокусоване більше на тестування Rails, але наша мета створити тестові рекомендації для більшості мов і фреймворків(таких як Scala, Elixir, React). Якщо ви
       бажаєте додати рекомендації для своєї улюбленої мови програмування <a target="_blank" href="https://github.com/lelylan/betterspecs/issues">додайте issue</a>.

    </p>

    <p>

  </p>

  </article>


<article>

<h1><a name="describe">Опишіть ваші методи</a></h1>

<p>
Будьте впевнені який метод ви описуєте. Використовуєте Ruby конвенцію по іменуванню,
<code>.</code> (or <code>::</code>) для методів класу і <code>#</code> для методів об'єкта
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
describe 'the authenticate method for User' do
describe 'if the user is an admin' do
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
describe '.authenticate' do
describe '#admin?' do
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/2">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>

<article>

<h1><a name="contexts">Використовуйте контекст</a></h1>

<p>
Contexts це потужний метод, щоб зробити ваші тести чистими і впорядкованими(вони роблять тести
легкими для читання). Коли описуєте контекст, текст має починатися зі слів "when", "with" or "without".
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
it 'has 200 status code if logged in' do
  expect(response).to respond_with 200
end

it 'has 401 status code if not logged in' do
  expect(response).to respond_with 401
end
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
context 'when logged in' do
  it { is_expected.to respond_with 200 }
end

context 'when logged out' do
  it { is_expected.to respond_with 401 }
end
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/3">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>




<article>

<h1><a name="short">Лаконічний опис</a></h1>

<p>
Опис spec не має перевищувати 40 символів. Якщо це трапляється, розділіть його за допомогою context.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
it 'has 422 status code if an unexpected params will be added' do
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
context 'when not valid' do
  it { is_expected.to respond_with 422 }
end
{% endhighlight %}
</div>

<p>
В даному випадку ми видалили частину опису, що відносилась до коду статусу, яке було замінено
очікуваним результатом <code>is_expected</code>. Якщо ви запустите тест командою <code>rspec filename</code> ви отримаєте читаємий результат.
</p>


<div class="code-block">
<p class="spec-title">Відформатований результат</p>

{% highlight ruby %}
when not valid
  it should respond with 422
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/4">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="single">Єдиний очикуваний результат на тест</a></h1>

<p>
Єдиний очікуваний результат розуміється більш широко, як кожний тест має тільки одне твердження.
Це допоможе вам в пошуку можливих помилок, ідучи прямо то тесту, що впав, і робить ваш коди більш читаємим. В ізольваних юніт тестах, ви прагнете щоб кожен ваш приклад уточнював одну і тільки одну поведінку. Декілька очікувань в одному тесті це знак, що можливо ви уточнюєте декілька поведінок.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре (iзольовано)</p>

{% highlight ruby %}
it { is_expected.to respond_with_content_type(:json) }
it { is_expected.to assign_to(:resource) }
{% endhighlight %}
</div>

<p>
В будь-якому разі, в не ізольованих тестах(ті що інтегруються з БД, зовнішні вебсервіси, чи end-to-end тести), ви отримуєте масивний удар по продуктивності системи, в той час коли одне й те саме налаштування виконується кожний раз, тільки для того щоб зробити окреме очікування в кожному тесті. Для таких повільних тестів, це нормально перевіряти більше ніж одну очікувану поведінку.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре(не ізольовано)</p>

{% highlight ruby %}
it 'creates a resource' do
  expect(response).to respond_with_content_type(:json)
  expect(response).to assign_to(:resource)
end
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/5">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="all">Тестуйте всі можливі випадки</a></h1>

<p>
Тестування це хороша практика, але якщо ви не тестуєте граничні випадки, з цього не буде користі.
Тестуйте валідні, граничні і не валідні випадки. Наприклад, розглянемо наступний випадок.

</p>


<div class="code-block">
<p class="spec-title">Destroy Action</p>

{% highlight ruby %}
before_action :find_owned_resources
before_action :find_resource

def destroy
  render 'show'
  @consumption.destroy
end
{% endhighlight %}

<p>
Розповсюджена помилка: Цей тест перевіряє тільки чи був видалений ресурс. Але існує іще як мінімум два випдки граничні випадки: перший - ресурс не знайдений, другий - ресурс не належить. Візьміть за правило: думати про всі можливі вхідні дані і тестуйте їх
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
it 'shows the resource'
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
describe '#destroy' do

  context 'when resource is found' do
    it 'responds with 200'
    it 'shows the resource'
  end

  context 'when resource is not found' do
    it 'responds with 404'
  end

  context 'when resource is not owned' do
    it 'responds with 404'
  end
end
{% endhighlight %}

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/6">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="expect">Expect проти Should синтаксису</a></h1>

<p>
В нових проектах використовуєте тільки <code>expect</code> синтаксис.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
it 'creates a resource' do
  response.should respond_with_content_type(:json)
end
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
it 'creates a resource' do
  expect(response).to respond_with_content_type(:json)
end
{% endhighlight %}
</div>

<p>
Налаштуйте RSpec таким чином, щоб він приймав тільки новий синтаксис. Таки чином вдасться запобігти появі повсюди обох синтаксисів.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
# spec_helper.rb
RSpec.configure do |config|
  # ...
  config.expect_with :rspec do |c|
    c.syntax = :expect
  end
end
{% endhighlight %}
</div>

<p>
  Очікування одним рядком або при наявному предметі тестування треба використовувати <code>is_expected.to</code>.
  </p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
context 'when not valid' do
  it { should respond_with 422 }
end
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
context 'when not valid' do
  it { is_expected.to respond_with 422 }
end
{% endhighlight %}
</div>

<p>
  Для старих проектів ви можете використовувати <a href="https://github.com/yujinakayama/transpec">transpec</a> для конвертування тестів з Should у новий синтаксис. Більше інформації про новий синтаксис RSpec з expectation дивіться <a href="http://myronmars.to/n/dev-blog/2012/06/rspecs-new-expectation-syntax">here</a> та <a href="http://myronmars.to/n/dev-blog/2013/07/the-plan-for-rspec-3#what_about_the_old_expectationmock_syntax">тут</a>.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/83">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="subject">Використовуєте subject</a></h1>

<p>
Якщо у вас є кілька тестів, що відносяться до однієї теми
використовуєте <code>subject{}</code> щоб зробити їх DRY.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
it { expect(assigns('message')).to match /it was born in Belville/ }
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
subject { assigns('message') }
it { is_expected.to match /it was born in Billville/ }
{% endhighlight %}
</div>

<p>
RSpec також має можливість використовувати subject з іменами(читайте більше <a href="https://www.relishapp.com/rspec/rspec-core/v/2-11/docs/subject">rspec subject</a>).
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
subject(:hero) { Hero.first }
it "carries a sword" do
  expect(hero.equipment).to include "sword"
end
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/7">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="let">Використовуєте let і let!</a></h1>

<p>
Використовуйте <code>let</code> коли вам необхідно присвоїти значення крім тих випадків
коли можна використовувати <code>before</code>. При використанні <code>let</code> відбувається
ледаче завантаження(lazy loads), змінна завантажується тільки в той момент, коли до неї звертаються в перший раз в конкретному тесті, і кешується до тих пір поки тест не закінчиться.
Дійсно хороший і глибокий опис того, що таке <code>let</code> ви можете знайти в цій
<a href="http://stackoverflow.com/questions/5359558/when-to-use-rspec-let/5359979#5359979">відповіді на stackoverflow</a>.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
describe '#type_id' do
  before { @resource = FactoryBot.create :device }
  before { @type     = Type.find @resource.type_id }

  it 'sets the type_id field' do
    expect(@resource.type_id).to equal(@type.id)
  end
end
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
describe '#type_id' do
  let(:resource) { FactoryBot.create :device }
  let(:type)     { Type.find resource.type_id }

  it 'sets the type_id field' do
    expect(resource.type_id).to equal(type.id)
  end
end
{% endhighlight %}
</div>

<p>
Використовуйте <code>let</code> щоб ініціалізувати величини через ледаче завантаження(lazy load)
у ваших тестах.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
context 'when updates a not existing property value' do
  let(:properties) { { id: Settings.resource_id, value: 'on' } }

  def update
    resource.properties = properties
  end

  it 'raises a not found error' do
    expect { update }.to raise_error Mongoid::Errors::DocumentNotFound
  end
end
{% endhighlight %}
</div>

<p>
Використовуйте <code>let!</code>, коли ви хочете оголосити змінну, коли блок вже визначений.
Це може бути корисно коли вам необхідно заповнити базу даних, для тестування запитів(queries) або  скоупів(scopes). Ось приклад того, що таке let насправді <a href="https://www.relishapp.com/rspec/rspec-core/v/2-11/docs/helper-methods/let-and-let">rspec let</a>).
</p>

<div class="code-block">
<p class="spec-title">Пояснення</p>

{% highlight ruby %}
# this use of let
let(:foo) { Foo.new }

# is very nearly equivalent to this:
def foo
  @foo ||= Foo.new
end
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/8">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="mock">Мокати запити(mock) чи не мокати</a></h1>

<p>
Глобально не зловживайте моками і тестуйте реальну поведінку, коли це можливо. Бо тестування
реальних кейсів корисне коли ви перевіряєте реальні процеси вашого застосунку.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
# simulate a not found resource
context "when not found" do

  before do
    allow(Resource).to receive(:where).with(created_from: params[:id])
      .and_return(false)
  end

  it { is_expected.to respond_with 404 }
end
{% endhighlight %}
</div>

<p>
Моки роблять ваші тести швидшими, але їх важко використовувати. Ви маєте добро розуміти їх
щоб використовувати їх за призначенням. Почитайте <a href="http://myronmars.to/n/dev-blog/2012/06/thoughts-on-mocking">цю статтю</a> щоб дізнатися більше про моки.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/9">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="data">Створюйте тільки ті дані, які вам потрібні</a></h1>

<p>
Якщо ви колись працювали в проектах середнього розміру(хоча це також можливо в малих проектах),
тести можуть бути важкими. Рішення - не завантажувати більше даних ніж це необхідно. Також якщо вам здається, що необхідно завантажити дюжину записів - вірогідно ви помиляєтесь.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
RSpec.describe User do
  describe ".top" do
    before { FactoryBot.create_list(:user, 3) }
    it { expect(described_class.top(2).size).to eq 2 }
  end
end
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/10">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="factories">Використовуйте фабрикиб, а не фікстури</a></h1>

<p>
Це стара рекомендація, але її слід гарно пам'ятати. Не використовуєте фікстури, оскільки їх важко контролювати, замість них використовуйте фабрики. Використовуєте їх, щоб уникнути багатослівності при створенні тестових даних(дізнайтеся більше про<a href="https://github.com/thoughtbot/factory_bot">Factory Bot</a>).
</p>
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
user = User.create(
  name: 'Genoveffa',
  surname: 'Piccolina',
  city: 'Billyville',
  birth: '17 Agoust 1982',
  active: true
)
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
user = FactoryBot.create :user
{% endhighlight %}
</div>

<p>
Одне важливе уточнення. Коли йде мова про юніт тести, найкраща практика буде не використовувати ні фікстури ні фабрики. Вмістить максимум доменної логіки в бібліотеки, які можна тестувати без
складних, тривалих сетапів з фабриками чи фікстурами. Читайте більше в<a href="http://blog.steveklabnik.com/posts/2012-07-14-why-i-don-t-like-factory_girl">цій статті</a>.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/11">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="matchers">Прості матчери</a></h1>

<p>
Використовуйте читаємі матчери і двічі перевірте вже доступні. <a href="https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers">rspec матчери</a>.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
lambda { model.save! }.to raise_error Mongoid::Errors::DocumentNotFound
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
expect { model.save! }.to raise_error Mongoid::Errors::DocumentNotFound
{% endhighlight %}
</div>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/12">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="shared">Shared Examples</a></h1>

<p>
Писати тести це чудово і з кожним днем ви пишете тести впевненіше. З часом ви почнете помічати дублювання коду повсюдно. Використовуйте Shared Examples щоб зробити свої тести DRY.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">Погано</p>

{% highlight ruby %}
describe 'GET /devices' do

  let!(:resource) { FactoryBot.create :device, created_from: user.id }
  let!(:uri)      { '/devices' }

  context 'when shows all resources' do

    let!(:not_owned) { FactoryBot.create factory }

    it 'shows all owned resources' do
      page.driver.get uri
      expect(page.status_code).to be(200)
      contains_owned_resource resource
      does_not_contain_resource not_owned
    end
  end

  describe '?start=:uri' do

    it 'shows the next page' do

      page.driver.get uri, start: resource.uri
      expect(page.status_code).to be(200)
      contains_resource resources.first
      expect(page).to_not have_content resource.id.to_s
    end
  end
end
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
describe 'GET /devices' do

  let!(:resource) { FactoryBot.create :device, created_from: user.id }
  let!(:uri)       { '/devices' }

  it_behaves_like 'a listable resource'
  it_behaves_like 'a paginable resource'
  it_behaves_like 'a searchable resource'
  it_behaves_like 'a filterable list'
end
{% endhighlight %}
</div>

<p>
З нашого досвіду, shared examples в основному використовують для контролерів. Оскільки моделі переважно відрізняються одна від одної, значною мірою. Дізнайтесь більше <a href="https://www.relishapp.com/rspec/rspec-core/v/3-2/docs/example-groups/shared-examples">rspec shared examples</a>.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/13">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="integration">Тестуйте те що ви бачите</a></h1>

<p>
Глибоко тестуйте ваші моделі і поведінку вашого додатку(інтеграційні тести). Не тестуйте контролери, це лише додасть зайвої складності вашим тестам.
</p>

<p>
Коли я тільки починав тестувати мої системи - я тестував контролери, тепер - ні. Тепер я лише створюю інтеграційні тести використовуючи RSpec і Capybara. Чому? Я вірю що треба тестувати те що ти бачиш, окрім цього тестування контролерів це додаткова робота,  яка зазвичай не стане у нагоді. Ви побачите, що більшість ваших тестів відносяться до моделей, а інтеграційні тести можуть легко групуватися в shared examples. Таким чином ви будуватимете чисте і читаєме тестове покриття.
</p>

<p>
Це досі тема дебатів в Ruby ком'юніті, і обидві сторони мають хорошу аргументацію, на підтримку своєї позиції. Сторона, що виступає за тестування контролерів, скаже що ваші інтеграційні тести не покривають всі випадки і що вони повільні. Обидва твердження хибні. Ви можете тестуванит всі випадки(чому б ні?) і ви можете запускати окремі файли з тестами, використовуючи автоматичні інструменти таки як Guard. В цьому випадку ви будете запускати лише ті тести, як потрібно не перериваючи процес.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/14">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="should">Не використовуйте should</a></h1>

<p>
Не використовуйте should коли описуєте свої тести. Використовуйте третю особу і теперішній час. Краще почніть використовувати новий <a href="http://myronmars.to/n/dev-blog/2012/06/rspecs-new-expectation-syntax">expectation</a> синтаксис.
</p>

<div class="code-block">
<p class="spec-title spec-wrong">bad</p>

{% highlight ruby %}
it 'should not change timings' do
  consumption.occur_at.should == valid.occur_at
end
{% endhighlight %}
</div>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
it 'does not change timings' do
  expect(consumption.occur_at).to equal(valid.occur_at)
end
{% endhighlight %}
</div>

<p>
Читайте <a href="https://github.com/should-not/should_not">the should_not gem</a> для примусового використання нового синтаксису в RSpec, а також <a href="https://github.com/siyelo/should_clean">the should_clean</a> gem для чистки RSpec тестів, які починаються на "should."
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/15">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="continuous">Автоматизуйте тести за допомогою guard</a></h1>

<p>
Запускати всі тести, після кожної зміни вашого проекту, може бути клопітно. Це віднімає багато часу і може порушувати робочій процес. За допомогою Guard ви можете автоматизувати ваші тести, запускаючи лише ті, які пов'язані з оновленими тестами, моделями, контролерами чи файлами з якими ви працюєте.
</p>

<div class="code-block">
<p class="spec-title spec-correct">good</p>

{% highlight ruby %}
bundle exec guard
{% endhighlight %}
</div>

Нижче ви можете бачити приклад Guardfile, з деякими базовими правилами.

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
guard 'rspec', cli: '--drb --format Fuubar --color', version: 2 do
  # run every updated spec file
  watch(%r{^spec/.+_spec\.rb$})
  # run the lib specs when a file in lib/ changes
  watch(%r{^lib/(.+)\.rb$}) { |m| "spec/lib/#{m[1]}_spec.rb" }
  # run the model specs related to the changed model
  watch(%r{^app/(.+)\.rb$}) { |m| "spec/#{m[1]}_spec.rb" }
  # run the view specs related to the changed view
  watch(%r{^app/(.*)(\.erb|\.haml)$}) { |m| "spec/#{m[1]}#{m[2]}_spec.rb" }
  # run the integration specs related to the changed controller
  watch(%r{^app/controllers/(.+)\.rb}) { |m| "spec/requests/#{m[1]}_spec.rb" }
  # run all integration tests when application controller change
  watch('app/controllers/application_controller.rb') { "spec/requests" }
end
{% endhighlight %}
</div>

<p>
Guard це чудовий інструмент, але як правило він не відповідає всім вашим потребам. Іноді ваш TDD процес працює найкраще з прив'язкою до клавіш(keybinding) що дозволяє запускати лише ті тести, які вам потрібні. Потім, ви можете запустити всі тести запускаючи rake task. Дивіться приклад keybinding для vim <a href="https://github.com/myronmarston/vim_files/blob/5bd4faad7c020ebcbf62dcbc59985262b4eacb53/vimrc.after#L61-103">тут</a> і дізнатися більше про <a href="https://github.com/guard/guard-rspec">guard-rspec</a>.>
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/16">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="faster">Швидші тести(предзавантажте Rails)</a></h1>

<p>
Коли запускається тест в Rails, також весь додаток Rails завантажується. Це потребує часу і це може зіпсувати ваш процес розробки. Щоб розв'язати проблему використовуйте рішення типу <a href="https://github.com/burke/zeus">Zeus</a>,
<a href="https://github.com/jstorimer/spin">Spin</a> чи
<a href="https://github.com/sporkrb/spork">Spork</a>.
Ці рішення передзавантажують ті бібліотеки, які (зазвичай) не змінюються. Вони перезавантажують ті частини додатки які зазвичай змінюються контролери, моделі, в'юхи фабрики та інше.
</p>

<p>
Тут ви можете знайти налаштування <a href="https://gist.github.com/3821012">spec helper</a> і  <a href="https://gist.github.com/3821031">Guardfile</a> на основі Spork. З цими налаштуваннями ви будете перезавантажувати весь додаток тільки якщо один з передзавантаженних файлів змінився(наприклад initializers). В цьому випадку окремі тести будуть запускатися надшвидко.
</p>

<p>
Мінус використання Spork є те, ви можете витратити години на те щоб зрозуміти чому один з файлів не перезавантажується, оскільки Spork жорстко патчить ваш код. Якщо у вас є приклади використання Spin чи іншого рішення <a href="https://github.com/lelylan/betterspecs/issues/17">дайте нам знати</a>.
</p>

<p>
За посиланням ви можете знайти налаштування <a href="https://gist.github.com/HuffMoody/5912373">Guardfile</a> для використання Zeus. В цьому випадку немає потреби модифікувати spec_helper, єдине що треб буде зробити - виконати `zeus start` в консолі, щоб запустити zeus сервер, до того, як запустити тести. Окрім цього Zeus має менш агресивний підхід ніж Spork, один суттєвий недолік - жорсткі вимоги до системи: Ruby 2.0 чи вище, а також операційна система що підтримує FSEvents або обов'язковий inotify.
</p>

<p>
Ці рішення часто критикуються. Це свого роду лейкопластир для проблеми, що вирішується через коректну архітектуру тестів, якщо завантажувати тільки необхідні залежності. Дізнайтесь більше в цьом  <a href="https://github.com/lelylan/betterspecs/issues/17">обговоренні</a>.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/17">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="stubbing">Запишіть HTTP запити</a></h1>

<p>
Іноді вам необхідне використання зовнішніх сервісів. В цьому випадку ви маєте записати ваші запити(stub) за допомогою, наприклад, webmock. Оскільки не варто покладатися на сторонні сервіси.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
context "with unauthorized access" do

  let(:uri) { 'http://api.lelylan.com/types' }
  before    { stub_request(:get, uri).to_return(status: 401, body: fixture('401.json')) }

  it "gets a not authorized notification" do
    page.driver.get uri
    expect(page).to have_content 'Access denied'
  end
end
{% endhighlight %}
</div>


<p>
Дізнайтесь більше про <a href="https://github.com/bblimke/webmock">webmock</a> і <a href="https://github.com/vcr/vcr">VCR</a>. А також  <a href="http://marnen.github.com/webmock-presentation/webmock.html">непогана презентація</a> як зміксувати їх разом.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/18">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="formatter">Корисний форматувач</a></h1>

<p>
Використовуйте форматувач - це дасть вам корисну інформацію про ваші тести. Мені дуже подобається fuubar. Для початку роботи додайте gem і вкажіть fuubar, як ваш форматувач за замовчуванням у вашому Guardfile.
</p>

<div class="code-block">
<p class="spec-title spec-correct">Добре</p>

{% highlight ruby %}
# Gemfile
group :development, :test do
  gem 'fuubar'

# .rspec configuration file
--drb
--format Fuubar
--color
{% endhighlight %}

<p>
Дізнайтеся більше про <a href="http://jeffkreeftmeijer.com/2010/fuubar-the-instafailing-rspec-progress-bar-formatter/">fuubar</a>.
</p>

<p>
<a href="https://github.com/andreareginato/betterspecs/issues/19">Обговорити цю рекомендацію &rarr;</a>
</p>

</article>



<article>

<h1><a name="contributing">Долучитися до проекту</a></h1>

<p>
“Не вагайтеся щоб зробити свій PR” слова які часто зустрічаються на GitHub, але це викликає в багатьох збентеження і страх. Не завжди очевидно, як долучитися до open source проектів, і тут можуть бути свої тонкощі. Якщо ви новачок в open source, подивіться ці <a href="https://egghead.io/series/how-to-contribute-to-an-open-source-project-on-github">відео</a> і ви будете озброєні інструментами, знаннями і розумінням для початку участі в світі open source проектів. В даному випадку, Better Specs потребує вашої допомоги в наступних задачах:
</p>

<p class="info">
  &rarr; Створити вказівки для тестування нових мов (<a target="_blank" href="https://github.com/lelylan/betterspecs/issues">відкрити issue</a>).<br>

   &rarr; Оновити застарілі рекомендації, які змінились з часом(<a target="_blank" href="https://github.com/lelylan/betterspecs/issues">відкрити issue</a>).<br>

   &rarr; Додати або оновити наявні переклади (<a target="_blank" href="https://github.com/lelylan/betterspecs/issues">відкрити issue</a>).<br>
  </span>
</p>

<p>
Дякуємо за ваш час, отримуйте задоволення від програмування і почніть контрибутити вже сьогодні в ті проекти які вам подобаються.
</p>

</article>
